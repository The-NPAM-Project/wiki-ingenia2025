# PASO 1
# popup("apagar laser, check pose", "Mensaje", False, False, blocking = True)

# Ahora los movimientos se hacen trasladando el TCP y moviendo a SRlaser_PLA!!!

global correccionX = 0.0000
global correccionY = 0.0000
global correccionZ = 0.0000

global SRlaser_PLA=p[0.10338, -0.95558, 0.004, -0.0054, -0.0053, 0.0116]

global cubo1 = p[-0.01366, 0.00366, 0.133, -0.91423, -1.58349, 1.58345]
cubo1 = pose_add(p[0, 0, 0, 0, 0, -0.7853982],cubo1)
cubo1 = pose_trans(cubo1,p[0.0110, -0.0270, -0.0038, 0,0,0])
set_tcp(cubo1)

# Todo el código está aprametrizado entorno a estos dos puntos
global p01_local = p[0, 0, 0, 0, 0, 0]
global p02_local = p[-0.018, -0.018, 0, 0, 0, 0]

global sleeptime = 3

# Posicion aproximada del laser con respecto a mesa
# global p01 = p[-0.889, -0.882, 0.5038, 1.2092, -1.2092, 1.2092]
# global p01 = p01_soporteAL

# global p02 = p[-0.662, -0.654, 0.5038, 1.2092, -1.2092, 1.2092]
# global p02 = p02_soporteAL

# movel(pose_trans(SRmesa, p01),a=1.2,v=0.003)
set_tcp(pose_trans(cubo1, p01_local))
movel(SRlaser_PLA, a = 1, v = 0.02)
sleep(sleeptime)

popup("Cama colocada aprox", "Mensaje", False, False, blocking = True)

# popup("encender laser", "Mensaje", False, False, blocking = True)

# global p1 = pose_add(p01, p[0.005, 0.005, 0, 0, 0, 0])
# global p2 = pose_add(p01, p[0.015, 0.005, 0, 0, 0, 0])
# global p3 = pose_add(p01, p[0.005, 0.015, 0, 0, 0, 0])

# Creamos nuevos TCPs localmente en función de p01_local

global p1_local = pose_add(p01_local, p[-0.005, -0.005, 0, 0, 0, 0])
global p2_local = pose_add(p01_local, p[-0.015, -0.005, 0, 0, 0, 0])
global p3_local = pose_add(p01_local, p[-0.005, -0.075, 0, 0, 0, 0])

# Medimos distancias con estos puntos para sacar el giro del plano
# Para el futuro, meter más puntos o ampliar el área con el doble cubo

# movel(pose_trans(SRmesa, p1),a=1.2,v=0.003)
# sleep(sleeptime)
# global d1=get_standard_analog_in(0)

set_tcp(pose_trans(cubo1, p1_local))
movel(SRlaser_PLA, a = 1, v = 0.003)
sleep(sleeptime)
global d1 = get_standard_analog_in(0)

# movel(pose_trans(SRmesa, p2),a=1.2,v=0.003)
# sleep(sleeptime)
# global d2=get_standard_analog_in(0)

set_tcp(pose_trans(cubo1, p2_local))
movel(SRlaser_PLA, a = 1, v = 0.003)
sleep(sleeptime)
global d2 = get_standard_analog_in(0)

# movel(pose_trans(SRmesa, p3),a=1.2,v=0.003)
# sleep(sleeptime)
# global d3=get_standard_analog_in(0)

set_tcp(pose_trans(cubo1, p3_local))
movel(SRlaser_PLA, a = 1, v = 0.003)
sleep(sleeptime)
global d3 = get_standard_analog_in(0)

# Pasar distancias a metros

global limsup = 370
global liminf = 330

d1 = (limsup-liminf) / (0.02-0.004) * (d1-0.004) + liminf
d1 = d1 / 1000
d2 = (limsup-liminf) / (0.02-0.004) * (d2-0.004) + liminf
d2 = d2 / 1000
d3 = (limsup-liminf) / (0.02-0.004) * (d3-0.004) + liminf
d3 = d3 / 1000

# Matemáticas para obtener el plano (ver CNIM23)

global dzx = ((p2_local[1] - p1_local[1]) * (d3 - d1) - (p3_local[1] - p1_local[1]) * (d2 - d1)) / ((p2_local[0] - p1_local[0]) * (p3_local[1] - p1_local[1]) - (p3_local[0] - p1_local[0]) * (p2_local[1] - p1_local[1]))
global dzy = ((p3_local[0] - p1_local[0]) * (d2 - d1) - (p2_local[0] - p1_local[0]) * (d3 - d1)) / ((p2_local[0] - p1_local[0]) * (p3_local[1] - p1_local[1]) - (p3_local[0] - p1_local[0]) * (p2_local[1] - p1_local[1]))
global normdz = pow(dzx, 2) + pow(dzy, 2)
normdz = pow(normdz, 0.5)

g = [dzx / normdz, dzy / normdz, 0]

m = [dzx, dzy, dzx * dzx + dzy * dzy]
normm = pow((pow(m[0], 2) + pow(m[1], 2) + pow(m[2], 2)), 0.5)
global m = [m[0] / normm, m[1] / normm, m[2] / normm]

n = [(p2_local[1] - p1_local[1]) * (p3_local[2] - p1_local[2]) - (p3_local[1] - p1_local[1]) * (p2_local[2] - p1_local[2]), (p2_local[2] - p1_local[2]) * (p3_local[0] - p1_local[0]) - (p3_local[2] - p1_local[2]) * (p2_local[0] - p1_local[0]), (p2_local[0] - p1_local[0]) * (p3_local[1] - p1_local[1]) - (p3_local[0] - p1_local[0]) * (p2_local[1] - p1_local[1])]
normn = pow((pow(n[0], 2) + pow(n[1], 2) + pow(n[2], 2)), 0.5)
global n = [n[0] / normn, n[1] / normn, n[2] / normn]

ur1xyz = [m[1] * n[2] - n[1] * m[2], m[2] * n[0] - n[2] * m[0], m[0] * n[1] - n[0] * m[1]]
normur1 = pow((pow(ur1xyz[0], 2) + pow(ur1xyz[1], 2) + pow(ur1xyz[2], 2)), 0.5)
global ur1 = p[0, 0, 0, 0, 0, 0]
ur1 = p[0, 0, 0, ur1xyz[0] / normur1, ur1xyz[1] / normur1, ur1xyz[2] / normur1]

global alpha1 = acos(g[0] * m[0] + g[1] * m[1] + g[2] * m[2])
global r1 = p[0, 0, 0, alpha1 * ur1[3], alpha1 * ur1[4], alpha1 * ur1[5]]

# popup("Comprobacion paso1", "Mensaje", False, False, blocking = True)

# global SRmesa2=pose_trans(SRmesa,pose_add(p[0,0,0,0,0,0],r1))

# global SRmesa2_base=pose_trans(SRmesa,  p[p01[0],p01[1],p01[2],0,0,0])
# SRmesa2_base=pose_trans(SRmesa2_base, r1)
# movel(pose_trans(SRmesa2_base, p[0,0,0, 1.2092, -1.2092, 1.2092]),a=1.2,v=0.003)
# global distlaser=analog_in[0]
# distlaser=(distlaser-0.004)*(35-25)/(0.02-0.004)+25
# global correccion=-(30-distlaser)/1000
# global SRmesa2C_base = pose_trans(SRmesa2_base, p[0, 0, correccion, 0,0,0])
# global SRmesa2 = SRmesa2C_base

# Aplicación paso 1

global cubo2 = pose_add(cubo1, r1)
set_tcp(pose_trans(cubo2, p01_local))
movel(SRlaser_PLA, a = 1, v = 0.003)
popup("Check cubo2", "Mensaje", False, False, blocking = True)
global distlaser = analog_in[0]
distlaser = (distlaser-0.004) * (limsup-liminf) / (0.02-0.004) + liminf
global correccion = -(350 - distlaser) / 1000
# cubo2=pose_trans(cubo2,p[0,0,-correccion,0,0,0])
global SRlaser_PLA2 = SRlaser_PLA
SRlaser_PLA2[2] = SRlaser_PLA2[2] + correccion
set_tcp(pose_trans(cubo2, p01_local))
movel(SRlaser_PLA2, a = 1, v = 0.003)
popup("Check cubo2 corregido", "Mensaje", False, False, blocking = True)

# # Comprobar en los mismos 3 puntos las distancias

# set_tcp(pose_trans(cubo2, p1_local))
# movel(SRlaser_PLA2, a = 1, v = 0.003)
# sleep(sleeptime)
# global d1_new = get_standard_analog_in(0)
# d1_new = (d1_new-0.004) * (35-25) / (0.02-0.004) + 25

# # movel(pose_trans(SRmesa, p2),a=1.2,v=0.003)
# # sleep(sleeptime)
# # global d2=get_standard_analog_in(0)

# set_tcp(pose_trans(cubo2, p2_local))
# movel(SRlaser_PLA2, a = 1, v = 0.003)
# sleep(sleeptime)
# global d2_new = get_standard_analog_in(0)
# d2_new = (d2_new-0.004) * (35-25) / (0.02-0.004) + 25

# # movel(pose_trans(SRmesa, p3),a=1.2,v=0.003)
# # sleep(sleeptime)
# # global d3=get_standard_analog_in(0)

# set_tcp(pose_trans(cubo2, p3_local))
# movel(SRlaser_PLA2, a = 1, v = 0.003)
# sleep(sleeptime)
# global d3_new = get_standard_analog_in(0)
# d3_new = (d3_new-0.004) * (35-25) / (0.02-0.004) + 25

# global SRmesa2_base=pose_trans(SRmesa, r1)
# movel(pose_trans(SRmesa2_base, p01),a=1.2,v=0.003)
# global distlaser=analog_in[0]
# distlaser=(distlaser-0.004)*(35-25)/(0.02-0.004)+25
# global correccion=-(30-distlaser)/1000
# global SRmesa2C_base = pose_trans(SRmesa2_base, p[0, 0, correccion, 0,0,0])
# global SRmesa2 = pose_trans(SRmesa2C_base, p[p01[0],p01[1],p01[2],0,0,0])


# global SRmesa2=r1
# movel(pose_trans(pose_trans(SRmesa,SRmesa2), p01),a=1.2,v=0.003)
# sleep(sleeptime)
# popup("Check srmesa2", "Mensaje", False, False, blocking=True)
# SRmesa2[0] = p01[0]
# SRmesa2[1] = p01[1]
# SRmesa2[2] = p01[2]
# global distlaser=analog_in[0]
# distlaser=(distlaser-0.004)*(35-25)/(0.02-0.004)+25
# global correccion=(30-distlaser)/1000
# SRmesa2[2]=SRmesa2[2]-correccion
# SRmesa2=pose_trans(SRmesa,SRmesa2)

# p02[0] = p02[0] - p01[0]
# p02[1] = p02[1] - p01[1]
# p02[2] = p02[2] - p01[2]

# p01[0]=0
# p01[1]=0
# p01[2]=0

# movel(pose_trans(SRmesa2, p01),a=1.2,v=0.003)
# popup("Check srmesa2 corregido", "Mensaje", False, False, blocking=True)

# global p_prueba=p01
# p_prueba[0]=p_prueba[0]+0.015
# p_prueba[1]=p_prueba[1]+0.015
# movel(pose_trans(SRmesa2, p_prueba),a=1.2,v=0.003)
# popup("Check p_prueba", "Mensaje", False, False, blocking=True)

# # Comprobación línea recta

# popup("Comprobar línea recta", "Mensaje", False, False, blocking = True)

# global pPrueba_local1 = p[-0.01, -0.01, 0, 0, 0, 0]
# set_tcp(pose_trans(cubo2, pPrueba_local1))
# movel(SRlaser_PLA2, a = 1, v = 0.003)
# # popup("Check pPrueba_local1", "Mensaje", False, False, blocking = True)

# global pPrueba_local2 = p[-0.01, -0.07, 0, 0, 0, 0]
# set_tcp(pose_trans(cubo2, pPrueba_local2))
# movel(SRlaser_PLA2, a = 1, v = 0.003)
# # popup("Check pPrueba_local2", "Mensaje", False, False, blocking = True)



# PASO 2
# popup("Paso 2", "Mensaje", False, False, blocking = True)

# v12 = vector de la diagonal del cubo en coord locales
global v12 = [p02_local[0] - p01_local[0], p02_local[1] - p01_local[1], p02_local[2] - p01_local[2]]

# amedio y bmedio como puntos en la diagonal para hacer el barrido paramétrico
global amedio = p01_local
amedio = pose_add(amedio, p[v12[0] / 16, v12[1] / 16, 0, 0, 0, 0])
global bmedio = p01_local
bmedio = pose_add(bmedio, p[6 * v12[0] / 16, 6 * v12[1] / 16, 0, 0, 0, 0])

# movel(pose_trans(SRmesa2, amedio), a = 1.2, v = 0.003)
set_tcp(pose_trans(cubo2, amedio))
movel(SRlaser_PLA2, a = 1, v = 0.003)
# popup("Check amedio", "Mensaje", False, False, blocking = True)

# matemáticas para puntos de inicio y fin del barrido

global v12rot = [-v12[1] / 2, v12[0] / 2]

global a_inic_xy = [amedio[0] + 1.5 * v12rot[0], amedio[1] + 1.5 * v12rot[1]]
global a_fin_xy = [amedio[0]-1.5 * v12rot[0], amedio[1]-1.5 * v12rot[1]]

global b_inic_xy = [bmedio[0] + 1.6 * v12rot[0], bmedio[1] + 1.6 * v12rot[1]]
global b_fin_xy = [bmedio[0]-1.6 * v12rot[0], bmedio[1]-1.6 * v12rot[1]]

global a_inic = amedio
a_inic [0] = a_inic_xy[0]
a_inic [1] = a_inic_xy[1]

global a_fin = amedio
a_fin [0] = a_fin_xy[0]
a_fin [1] = a_fin_xy[1]

global b_inic = bmedio
b_inic [0] = b_inic_xy[0]
b_inic [1] = b_inic_xy[1]

global b_fin = bmedio
b_fin [0] = b_fin_xy[0]
b_fin [1] = b_fin_xy[1]

# global a_prev=a_inic
# a_prev[2]=a_inic[2]
# movel(pose_trans(SRmesa2,a_prev), a=1.2, v=0.003)
# sync()

# popup("Empieza mov de a inic", "Mensaje", False, False, blocking = True)
# movel(pose_trans(SRmesa2, a_inic), a = 1.2, v = 0.003)
set_tcp(pose_trans(cubo2, a_inic))
movel(SRlaser_PLA2, a = 1, v = 0.003)
sync()

thread utillaje1_i ():
  while (True):
    # movel(pose_trans(SRmesa2, a_fin), a = 1.2, v = 0.003)
    set_tcp(pose_trans(cubo2, a_fin))
    movel(SRlaser_PLA2, a = 1, v = 0.003)
    sync()
  end
end

sync()

global limA = 0.015

if (analog_in[0] > limA):
  global thread_handler_2 = run utillaje1_i()
  sync()
  while (analog_in[0] > limA):
    sync()
  end
  kill thread_handler_2
  sleep(sleeptime)
  global p4_joint = get_actual_joint_positions()
  set_tcp(cubo2)
  global p4_flange = get_forward_kin(p4_joint)
  # global p4_base = get_actual_tcp_pose()
  global p4_cubo = pose_sub(SRlaser_PLA2, p4_flange)
  global check_p4_cubo = p4_cubo
  sync()
end

sync()
# movel(pose_trans(SRmesa2, amedio), a = 1.2, v = 0.003)
set_tcp(pose_trans(cubo2, amedio))
movel(SRlaser_PLA2, a = 1, v = 0.003)
sync()
if (analog_in[0] < limA):
  global thread_handler_3 = run utillaje1_i()
  sync()
  while (analog_in[0] < limA):
    sync()
  end
  kill thread_handler_3
  sleep(sleeptime)
  global p5_joint = get_actual_joint_positions()
  set_tcp(cubo2)
  global p5_flange = get_forward_kin(p5_joint)
  # global p5_base = get_actual_tcp_pose()
  global p5_cubo = pose_sub(SRlaser_PLA2, p5_flange)
  global check_p5_cubo = p5_cubo
  sync()
end

# popup("Empieza mov de b inic", "Mensaje", False, False, blocking = True)
# movel(pose_trans(SRmesa2, b_inic), a = 1.2, v = 0.003)
set_tcp(pose_trans(cubo2, b_inic))
movel(SRlaser_PLA2, a = 1, v = 0.003)

thread utillaje2_i ():
  while (True):
    # movel(pose_trans(SRmesa2, b_fin), a = 1.2, v = 0.003)
    set_tcp(pose_trans(cubo2, b_fin))
    movel(SRlaser_PLA2, a = 1, v = 0.003)
    sync()
  end
end
sync()

if (analog_in[0] > limA):
  global thread_handler_4 = run utillaje2_i()
  sync()
  while (analog_in[0] > limA):
    sync()
  end
  kill thread_handler_4
  sleep(sleeptime)
  global p6_joint = get_actual_joint_positions()
  set_tcp(cubo2)
  global p6_flange = get_forward_kin(p6_joint)
  # global p6_base = get_actual_tcp_pose()
  global p6_cubo = pose_sub(SRlaser_PLA2, p6_flange)
  global check_p6_cubo = p6_cubo
  sync()
end
sync()
# movel(pose_trans(SRmesa2, bmedio), a = 1.2, v = 0.005)
set_tcp(pose_trans(cubo2, bmedio))
movel(SRlaser_PLA2, a = 1, v = 0.003)
sync()
if (analog_in[0] < limA):
  global thread_handler_5 = run utillaje2_i()
  sync()
  while (analog_in[0] < limA):
    sync()
  end
  kill thread_handler_5
  sleep(sleeptime)
  global p7_joint = get_actual_joint_positions()
  set_tcp(cubo2)
  global p7_flange = get_forward_kin(p7_joint)
  # global p7_base = get_actual_tcp_pose()
  global p7_cubo = pose_sub(SRlaser_PLA2, p7_flange)
  global check_p7_cubo = p7_cubo
  sync()
end

sync()

# global fin = p7_base
# fin[2] = fin[2] - 0.05

# fin de los barridos
# popup("fin de los barridos", "Mensaje", False, False, blocking = True)


# antiSRlaser_PLA2 = pose_inv(SRlaser_PLA2)
# global p4 = pose_trans(antiSRlaser_PLA2, p4_base)
# global p5 = pose_trans(antiSRlaser_PLA2, p5_base)
# global p6 = pose_trans(antiSRlaser_PLA2, p6_base)
# global p7 = pose_trans(antiSRlaser_PLA2, p7_base)

global p4 = p4_cubo
global p5 = p5_cubo
global p6 = p6_cubo
global p7 = p7_cubo

det = ((p4[0] - p6[0]) * (p5[1] - p7[1]) - (p4[1] - p6[1]) * (p5[0] - p7[0]))
t1 = ((p5[0] - p4[0]) * (p5[1] - p7[1]) - (p5[1] - p4[1]) * (p5[0] - p7[0])) / det
t2 = ((p4[0] - p6[0]) * (p5[1] - p4[1]) - (p4[1] - p6[1]) * (p5[0] - p4[0])) / det

global origen = pose_sub(p4, p6)
origen[0] = origen[0] * t1
origen[1] = origen[1] * t1
origen[2] = origen[2] * t1
origen = pose_add(p4, origen)
# global Torigen = p[origen[0], origen[1], origen[2], 0, 0, 0]
global Torigen = p[origen[0]-correccionX, origen[1]-correccionY, 0-correccionZ, 0, 0, 0]
global eje_x = pose_sub(p5, p7)
eje_x2 = [eje_x[0], eje_x[1], eje_x[2]]
normeje_x = pow((pow((eje_x2[0]), 2) + pow((eje_x2[1]), 2) + pow((eje_x2[2]), 2)), 0.5)
eje_x2[0] = eje_x2[0] / normeje_x
eje_x2[1] = eje_x2[1] / normeje_x
eje_x2[2] = eje_x2[2] / normeje_x

global alpha2 = acos(eje_x2[0])
global y_gorro = pose_sub(p4, p6)
y0 = y_gorro[0]
y1 = y_gorro[1]
y2 = y_gorro[2]
global ur2 = [0, 0, 0]
ur2[0] = (-1) * y2 * eje_x2[1] + y1 * eje_x2[2]
ur2[1] = y2 * eje_x2[0] - y0 * eje_x2[2]
ur2[2] = (-1) * y1 * eje_x2[0] + y0 * eje_x2[1]
normur2 = pow((pow((ur2[0]), 2) + pow((ur2[1]), 2) + pow((ur2[2]), 2)), 0.5)
ur2[0] = ur2[0] / normur2
ur2[1] = ur2[1] / normur2
ur2[2] = ur2[2] / normur2

# global r2=p[0,0,0,alpha2*ur2[0],alpha2*ur2[1],alpha2*ur2[2]]
global r2 = p[0, 0, 0, 0, 0, alpha2]


# popup("revisar matemáticas", "Mensaje", False, False, blocking = True)

global cubo3 = pose_trans(cubo2, Torigen)
global cubo4 = pose_trans(cubo3, r2)
# # # global SRlaser=pose_add(SRmesa2,r2)
# # # SRlaser=pose_add(SRlaser,Torigen)

# # # movel(pose_trans(SRlaser,p01_local),a=1.2,v=0.003)

# # global r2 = p[Torigen[0], Torigen[1], Torigen[2], alpha2 * ur2[0], alpha2 * ur2[1], alpha2 * ur2[2]]
# # global r2_inv = pose_inv(r2)

# # global SRlaser = pose_trans(SRmesa2, r2)

# # movel(pose_trans(SRlaser, p01_local), a = 1.2, v = 0.003)

# popup("check paso 2, apagar laser", "Mensaje", False, False, blocking = True)

set_tcp(cubo4)
movel(SRlaser_PLA2, a = 1, v = 0.003)

# global distlaser = analog_in[0]
# distlaser = (distlaser-0.004) * (35-25) / (0.02-0.004) + 25
# global correccion = -(30 - distlaser) / 1000
# # cubo2=pose_trans(cubo2,p[0,0,-correccion,0,0,0])
global SRlaser_PLA3 = SRlaser_PLA2
# SRlaser_PLA3[2] = SRlaser_PLA3[2] + correccion
# set_tcp(cubo4)
# movel(SRlaser_PLA3, a = 1, v = 0.003)

# global cubo4 = cubo2
# global SRlaser_PLA3 = SRlaser_PLA2

popup("fin de la calibracion", "Mensaje", False, False, blocking = True)